using Anis.App.Views;
using Anis.Core.Domain;
using Anis.Core.Interfaces;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;

namespace Anis.App.MVVM.ViewModels;

public partial class ClipsManagerViewModel : ObservableObject
{
    private readonly IClipRepository _clipRepository;
    private readonly IAudioPlayer _audioPlayer;
    private readonly IScheduler _scheduler;
    private readonly IServiceProvider _serviceProvider;
    private readonly string _storagePath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "Anis");

    [ObservableProperty]
    private ObservableCollection<Clip> _clips = new();

    // --- THE FIX STARTS HERE ---
    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(PlayClipCommand))]
    private Clip? currentlyPlayingClip; // Use camelCase for the private field

    // Constructor remains the same...
    public ClipsManagerViewModel(IClipRepository clipRepository, IAudioPlayer audioPlayer, IScheduler scheduler, IServiceProvider serviceProvider)
    {
        _clipRepository = clipRepository;
        _audioPlayer = audioPlayer;
        _scheduler = scheduler;
        _serviceProvider = serviceProvider;
        LoadClipsAsync();
    }

    private async void LoadClipsAsync()
    {
        var clipsList = await _clipRepository.GetClipsAsync();
        Clips = new ObservableCollection<Clip>(clipsList);
    }

    [RelayCommand(CanExecute = nameof(CanPlayClip))]
    private async Task PlayClipAsync(Clip? clip)
    {
        if (clip == null || clip.FilePath == null) return;

        _audioPlayer.Stop();

        // Use the public property generated by the source generator (PascalCase)
        CurrentlyPlayingClip = clip;

        var fullPath = Path.Combine(_storagePath, clip.FilePath);

        await _audioPlayer.PlayAsync(fullPath, 0.8);

        // Use the public property
        CurrentlyPlayingClip = null;
    }

    private bool CanPlayClip(Clip? clip)
    {
        // Use the public property
        return clip != CurrentlyPlayingClip;
    }

    [RelayCommand]
    private void StopPlayback()
    {
        _audioPlayer.Stop();
        // Use the public property
        CurrentlyPlayingClip = null;
    }
    // --- THE FIX ENDS HERE ---

    // ... (The rest of the methods: DeleteClipAsync, EditClipAsync, RefreshClips, AddNewClip remain EXACTLY the same)
    [RelayCommand]
    private async Task DeleteClipAsync(Clip? clip)
    {
        if (clip == null) return;

        var result = MessageBox.Show($"هل أنت متأكد من حذف المقطع: '{clip.Title}'؟\nسيتم حذف الملف الصوتي نهائيًا.",
                                     "تأكيد الحذف", MessageBoxButton.YesNo, MessageBoxImage.Warning);

        if (result == MessageBoxResult.Yes)
        {
            Clips.Remove(clip);
            await _clipRepository.SaveClipsAsync(Clips);
            try
            {
                var filePath = Path.Combine(_storagePath, clip.FilePath);
                if (File.Exists(filePath))
                {
                    File.Delete(filePath);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Could not delete audio file: {ex.Message}");
            }
            await _scheduler.RefreshDataAsync();
        }
    }

    [RelayCommand]
    private async Task EditClipAsync(Clip? clipToEdit)
    {
        if (clipToEdit == null) return;

        var editVM = _serviceProvider.GetRequiredService<AddClipViewModel>();
        editVM.SetClipForEditing(clipToEdit);

        var editView = new AddClipView { DataContext = editVM };
        var result = editView.ShowDialog();

        if (result == true)
        {
            LoadClipsAsync();
            await _scheduler.RefreshDataAsync();
        }
    }

    public void RefreshClips()
    {
        LoadClipsAsync();
    }

    [RelayCommand]
    private void AddNewClip()
    {
        var addClipView = new AddClipView
        {
            DataContext = _serviceProvider.GetRequiredService<AddClipViewModel>(),
            WindowStartupLocation = WindowStartupLocation.CenterScreen
        };

        var dialogResult = addClipView.ShowDialog();

        if (dialogResult == true)
        {
            RefreshClips();
        }
    }
}